<?xml version='1.1' encoding='UTF-8'?>
<flow-definition plugin="workflow-job@2.38">
  <actions/>
  <description>Poll all the agents for any reason they may be off-line.  Agents that are marked &apos;bad&apos; will need to be started manually.</description>
  <keepDependencies>false</keepDependencies>
  <properties>
    <hudson.plugins.jira.JiraProjectProperty plugin="jira@3.0.15"/>
    <org.jenkinsci.plugins.workflow.job.properties.DisableConcurrentBuildsJobProperty/>
    <org.jenkinsci.plugins.workflow.job.properties.DisableResumeJobProperty/>
    <hudson.plugins.throttleconcurrents.ThrottleJobProperty plugin="throttle-concurrents@2.0.2">
      <maxConcurrentPerNode>0</maxConcurrentPerNode>
      <maxConcurrentTotal>0</maxConcurrentTotal>
      <categories class="java.util.concurrent.CopyOnWriteArrayList"/>
      <throttleEnabled>false</throttleEnabled>
      <throttleOption>project</throttleOption>
      <limitOneJobWithMatchingParams>false</limitOneJobWithMatchingParams>
      <paramsToUseForLimit></paramsToUseForLimit>
    </hudson.plugins.throttleconcurrents.ThrottleJobProperty>
    <jenkins.model.BuildDiscarderProperty>
      <strategy class="hudson.tasks.LogRotator">
        <daysToKeep>5</daysToKeep>
        <numToKeep>-1</numToKeep>
        <artifactDaysToKeep>-1</artifactDaysToKeep>
        <artifactNumToKeep>-1</artifactNumToKeep>
      </strategy>
    </jenkins.model.BuildDiscarderProperty>
    <org.jenkinsci.plugins.workflow.job.properties.PipelineTriggersJobProperty>
      <triggers>
        <hudson.triggers.TimerTrigger>
          <spec>H/15 * * * * </spec>
        </hudson.triggers.TimerTrigger>
      </triggers>
    </org.jenkinsci.plugins.workflow.job.properties.PipelineTriggersJobProperty>
  </properties>
  <definition class="org.jenkinsci.plugins.workflow.cps.CpsFlowDefinition" plugin="workflow-cps@2.80">
    <script>def agents = [:]

hudson.model.Hudson.instance.getNodes().collect {
    agents[it.name] = {
        stage (it.name) {
            // if (it.getComputer()?.getOfflineCause() != null) {
            //     error it.name.padRight(25) + it.getComputer()?.countBusy().toString().padRight(5) + it.getComputer()?.getOfflineCause()
            // }
            
            switch (it.getComputer()?.getOfflineCause()) {
                case hudson.slaves.OfflineCause.ChannelTermination:
                    def atTime = it.getComputer()?.getOfflineCause().getTime()
                    echo it.name.padRight(25) + it.getComputer()?.countBusy().toString().padRight(5) + &quot;Channel Termination at &quot; + atTime.toString()
                    break
                case hudson.slaves.OfflineCause.LaunchFailed:
                    def atTime = it.getComputer()?.getOfflineCause().getTime()
                    error &quot;Launch Failed at &quot; + atTime.toString()
                    break
                case hudson.slaves.OfflineCause.UserCause:
                    echo it.name.padRight(25) + it.getComputer()?.countBusy().toString().padRight(5) + &quot;is taken Offline by User&quot;
                    break
                case hudson.slaves.OfflineCause.IdleOfflineCause:
                    echo it.name.padRight(25) + it.getComputer()?.countBusy().toString().padRight(5) + &quot;is Idle then went Offline&quot;
                    break
                case null:
                    echo it.name.padRight(25) + it.getComputer()?.countBusy().toString().padRight(5) + &quot;is ONLINE&quot;
                    break
                default:
                    error it.name.padRight(25) + it.getComputer()?.countBusy().toString().padRight(5) + it.getComputer()?.getOfflineCause()
                    break
            } // switch
        } // stage
    }
}

parallel(agents)</script>
    <sandbox>true</sandbox>
  </definition>
  <triggers/>
  <disabled>true</disabled>
</flow-definition>