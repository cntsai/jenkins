<?xml version="1.1" encoding="UTF-8" standalone="no"?><flow-definition plugin="workflow-job@1145.v7f2433caa07f">
  <actions>
    <org.jenkinsci.plugins.pipeline.modeldefinition.actions.DeclarativeJobAction plugin="pipeline-model-definition@1.9.3"/>
    <org.jenkinsci.plugins.pipeline.modeldefinition.actions.DeclarativeJobPropertyTrackerAction plugin="pipeline-model-definition@1.9.3">
      <jobProperties/>
      <triggers/>
      <parameters/>
      <options/>
    </org.jenkinsci.plugins.pipeline.modeldefinition.actions.DeclarativeJobPropertyTrackerAction>
  </actions>
  <description>daily build u84 rtlsim verilator binary&#13;
&lt;p&gt;Owners: Hsinyi Lee, Fu-Ching Yang&#13;
Backup: Mike Schoenfelder</description>
  <keepDependencies>false</keepDependencies>
  <properties>
    <hudson.plugins.jira.JiraProjectProperty plugin="jira@3.7"/>
    <com.sonyericsson.rebuild.RebuildSettings plugin="rebuild@1.33">
      <autoRebuild>false</autoRebuild>
      <rebuildDisabled>false</rebuildDisabled>
    </com.sonyericsson.rebuild.RebuildSettings>
    <hudson.plugins.throttleconcurrents.ThrottleJobProperty plugin="throttle-concurrents@2.6">
      <maxConcurrentPerNode>0</maxConcurrentPerNode>
      <maxConcurrentTotal>0</maxConcurrentTotal>
      <categories class="java.util.concurrent.CopyOnWriteArrayList"/>
      <throttleEnabled>false</throttleEnabled>
      <throttleOption>project</throttleOption>
      <limitOneJobWithMatchingParams>false</limitOneJobWithMatchingParams>
      <paramsToUseForLimit/>
    </hudson.plugins.throttleconcurrents.ThrottleJobProperty>
    
    <org.jenkinsci.plugins.workflow.job.properties.PipelineTriggersJobProperty>
      <triggers/>
    </org.jenkinsci.plugins.workflow.job.properties.PipelineTriggersJobProperty>
  </properties>
  <definition class="org.jenkinsci.plugins.workflow.cps.CpsFlowDefinition" plugin="workflow-cps@2660.vb_c0412dc4e6d">
    <script>#!groovy

def _slack_channel_for_build='#tw-perf-alert'
slack_channel_for_build='#tw-perf-alert'

build_config = [
    'p55':          'p55',
    'p55_l1pf_off': 'p55',
    'p65':          'p65',
    'p65_l1pf_off': 'p65',
    'dod_golden_makeup': ''
]
githash=[:]

def notifyBySlack(channel, result='', message='')
{
    result = result == null ? 'SUCCESS' : result
    def color=['FAILURE': '#A30200',
               'BUILD_FAIL': '#A30200',
               'PERF_CHANGE':'#DAA038',
               'UNSTABLE': '#DAA038',
               'Back to normal': '#2EB886',
               'SUCCESS': '#2EB886']
    slackSend(
        channel: channel,
        color:color[result],
        message: """${env.JOB_NAME} - #${env.BUILD_ID} - ${result} (&lt;${env.RUN_DISPLAY_URL}|Open&gt;)
$message""")
}

def checkVersion(config)
{
    def build = build_config[config]
    githash[config] = sh(script:"basename \$(readlink -f /work/sparta/rtlsim/$build/latest)", returnStdout:true).replaceAll("\\s","")
    if (fileExists("../../${githash[config]}/$config/run.me")) {
        notifyBySlack(slack_channel_for_build, 'SKIP', "no new $build rtlsim build (${githash[config]})")
        return false
    }
    return true
}

def runTest(config, jobs, channel=null)
{
    def result=''
    dir ("../../$config/${githash[config]}") {
        stage('run') {
            sh "chmod g+w .. . || true"
            catchError(buildResult: 'FAILURE', stageResult: 'FAILURE') {
            sh """
               JOBS=$jobs /work/sparta/scripts/jenkins/rtlsim_correlate.sh $config ${githash[config]}
               """
            }
            sh "[ ! -s log ] || cp log $WORKSPACE/${config}.err"
        }

        /*
         * check result
         */
        if (channel){
        stage('check_perf_change') {
            catchError(buildResult: 'UNSTABLE', stageResult: 'UNSTABLE') {
            try {
                sh """
                    [ ! -s bm_alert.log ] || cp bm_alert.log $WORKSPACE/${config}.perf.log
                    cat bm_alert.log || true; [ ! -s bm_alert.log ]
                """
            } catch (e) {
                result = 'PERF_CHANGE'
                    notifyBmChanged()
                throw e
            }}
        }}
    }
    stage('check_run_failed') {
        catchError(buildResult: 'FAILURE', stageResult: 'FAILURE') {
        try {
            sh "cat ${config}.err || true; ! [ -s ${config}.err ]"
        } catch (e) {
            result = 'FAILURE'
            throw e
        }}
        if (channel &amp;&amp; result){
            sendErrorLogBySlack(channel, result, config)
        }
        sh """
            cd ..
            rm -rf $config/${githash[config]}-WStmp || true
        """
    }
}

def readFileWithMaxLen(filename, maxlength) {
    def msg = readFile(filename)
    print(msg)
    if (msg.length() &gt; maxlength) {
        msg = msg.substring(0, maxlength)
            msg = "$msg ..."
    }else if (msg.length() == 0) {
        return ''
    }
    return "```$msg```\n"
}

def notifyBmChanged()
{
    def build = sh(script:"grep 'config:' build.yaml | awk -v ORS= '{print \$2}'", returnStdout:true)
    def url = "http://vis01.internal.sifive.com:8203/d/k1pcacXMk/mallard-performance-regression?var-build=$build"
    def msg = readFileWithMaxLen("bm_alert.log", 1000)
    notifyBySlack('#mallard', 'PERF_CHANGE', "$msg (&lt;$url|Dashboard&gt;)")
}

def sendErrorLogBySlack(channel, status, config=false) {
    def msg = ''
    if (config) {
        configs = [config]
    } else {
        configs = build_config.keySet() as List
    } 
    configs.each {
        config = it
        if (fileExists("${config}.err")) {
            msg += "${config}\n" + readFileWithMaxLen("${config}.err", 500)
            sh "rm -f ${config}.err"
        }
        if (fileExists("${config}.perf.log")) {
            msg += "$config perf change\n" + readFileWithMaxLen("${config}.perf.log", 500)
            sh "rm -f ${config}.perf.log"
        }
    }
    notifyBySlack(channel, status, msg)
}

def checkMissDodGolden()
{
    return sh(script:"""
        [ "\$(/work/sparta/scripts/jenkins/dod_golden_makeup.sh gen_cmd | tee makeup.run.me)" ]
    """, returnStatus:true)
}

def dodGoldenMakeup()
{
    catchError(buildResult: 'FAILURE', stageResult: 'FAILURE') {
        sh "parallel --verbose -j 8 &lt; makeup.run.me"
    }
    catchError(buildResult: 'FAILURE', stageResult: 'FAILURE') {
    try {
        sh """
            /work/sparta/scripts/jenkins/dod_golden_makeup.sh check_result &gt; dod_golden_makeup.err
            [ ! -s dod_golden_makeup.err ] || ! cat dod_golden_makeup.err
        """
    } catch (e) {
        notifyBySlack(slack_channel_for_build, 'FAILURE',
                "dod_golden_makeup\n" + readFileWithMaxLen("dod_golden_makeup.err", 1000))
	throw e
    }}
}

pipeline
{
    agent {
        node {
            label 'perf_regr_agent_rhel8'
            customWorkspace "/work/sparta/regression/${JOB_NAME}/workspace/${BUILD_NUMBER}"
        }
    }
    environment {
        SLURM_ACCOUNT="perf_ci"
        SALLOC_ACCOUNT="perf_ci"
        SLURM_BATCH="perf_ci"
    }
    stages {
        stage('rtlsim_correlation') { parallel {
            stage('p65') {
                when {
                    expression { return checkVersion('p65') }
                }
                steps {
                    runTest('p65', 200, , '#sparta-veracity-regressions')
                }
            }
            stage('p65_l1pf_off') {
                when {
                    expression { return checkVersion('p65_l1pf_off') }
                }
                steps {
                    runTest('p65_l1pf_off', 50)
                }
                post { failure {
                    sendErrorLogBySlack(slack_channel_for_build, 'FAILURE')
                }}
            }
            stage('dod_golden_makeup') {
                when {
                    expression {
                        return 0 == sh(script:"""
                            [ "\$(/work/sparta/scripts/jenkins/dod_golden_makeup.sh gen_cmd | tee makeup.run.me)" ]
                        """, returnStatus:true)
                    }
                }
                steps {
                    dodGoldenMakeup()
                }
                post { failure {
                    notifyBySlack(_slack_channel_for_build, 'FAILURE', 'dodGoldenMakeup failed')
                }}
            }
        }}
    }
    post {
        fixed {
            notifyBySlack(_slack_channel_for_build, 'Back to normal')
        }
        always {
            sh """
                find ../.. -mindepth 1 -maxdepth 2 -mtime +7 -exec rm -rf {} +
            """
        }
        cleanup {
            deleteDir()
        }
    }
}</script>
    <sandbox>true</sandbox>
  </definition>
  <triggers/>
  <authToken>na2x6ZN7ZHXpDkwG</authToken>
  <disabled>false</disabled>
</flow-definition>